from typing import Optional, Dict, Any
from sqlalchemy.exc import SQLAlchemyError
import uuid
from core.database import SessionLocal
from db import models


# ---------- CREATE PRODUCT ----------
def seller_create_product_tool(
    *,
    seller_id: int,
    name: str,
    price: float,
    stock_quantity: int,
    category_id: int,
    description: Optional[str] = None,
):
    """
    Create a new product for a seller
    """

    db = SessionLocal()
    try:
        # ðŸ”’ SKU GENERATED BY BACKEND (NOT LLM)
        sku = f"SKU-{uuid.uuid4().hex[:10].upper()}"

        product = models.Product(
            name=name,
            description=description,
            price=price,
            sku=sku,                      # âœ… FIX
            stock_quantity=stock_quantity,
            category_id=category_id,
            seller_id=seller_id,
        )

        db.add(product)
        db.commit()
        db.refresh(product)

        return {
            "status": "ok",
            "product": {
                "id": product.id,
                "name": product.name,
                "price": product.price,
                "stock_quantity": product.stock_quantity,
                "sku": product.sku,
            },
        }

    except SQLAlchemyError as e:
        db.rollback()
        return {
            "status": "error",
            "error": str(e),
        }

    finally:
        db.close()
# ---------- UPDATE PRICE ----------

def seller_update_price_tool(
    *,
    product_id: int,
    new_price: float,
) -> Dict[str, Any]:
    db = SessionLocal()
    try:
        product = db.query(models.Product).filter(
            models.Product.id == product_id,
            models.Product.is_deleted == False
        ).first()

        if not product:
            return {"status": "error", "error": "Product not found"}

        product.price = new_price
        db.commit()

        return {
            "status": "ok",
            "product_id": product_id,
            "new_price": new_price,
        }

    except SQLAlchemyError as e:
        db.rollback()
        return {"status": "error", "error": str(e)}

    finally:
        db.close()
